import { A } from '@ember/array';
import { isNone } from '@ember/utils';
import { all } from 'rsvp';
import { getOwner } from '@ember/application';
import { getJsonForClass, getJsonForAssociation, getJsonForAggregation, getJsonForInheritance } from './get-json-for-diagram';

/**
  Find autogenerated diagram.
*/
function findAutogeneratedDiagram(store, className, currentProjectContext) {
  let system = currentProjectContext.getAutogeneratedSystemModel();
  let diagrams = system.get('diagrams').toArray();
  let nameAutogeneratedDiagram = `AutogeneratedDiagramForClass_${className}`;
  let findDiagram = diagrams.findBy('name', nameAutogeneratedDiagram);
  let diagram = findDiagram ? findDiagram : store.createRecord('fd-dev-uml-cad', {
    name: nameAutogeneratedDiagram,
    primitivesJsonString: '[]',
    caseObjectsString: '',
    subsystem: system
  });

  return A([diagram]);
}

/**
  Find diagram.
*/
function findDiagrams(store, currentProjectContext, firstClassName, secondClassName, link) {
  let stagePk = currentProjectContext.getCurrentStage();

  // Exist current class on diagram.
  let allDiagrams = store.peekAll('fd-dev-uml-cad');
  let diagramsCurrentStage = allDiagrams.filterBy('subsystem.stage.id', stagePk);
  let diagrams;

  let diagramsWithFirstClass = A(diagramsCurrentStage).filter(function(diagram) {
    let caseObjectsString = diagram.get('caseObjectsString');
    return !isNone(caseObjectsString) && caseObjectsString.indexOf(`Class:(${firstClassName})`) !== -1;
  });

  if (!isNone(secondClassName)) {
    let diagramsWithClasses = A(diagramsWithFirstClass).filter(function(diagram) {
      let caseObjectsString = diagram.get('caseObjectsString');
      return !isNone(caseObjectsString) && caseObjectsString.indexOf(`Class:(${secondClassName})`) !== -1;
    });

    let linkId = link.get('id');
    diagrams = A(diagramsWithClasses).filter(function(diagram) {
      let primitivesJsonString = diagram.get('primitivesJsonString');
      let primitivesJsonArray = A(JSON.parse(primitivesJsonString));
      let repositoryObject = primitivesJsonArray.findBy('RepositoryObject', '{' + linkId + '}');
      return !isNone(repositoryObject);
    });
  } else {
    diagrams = diagramsWithFirstClass;
  }

  if (diagrams.length === 0) {
    diagrams = findAutogeneratedDiagram(store, firstClassName, currentProjectContext);
  }

  return A(diagrams);
}

/**
  Update diagram data in PrimitivesJson.
*/
function updatePrimitivesJson(primitivesJsonArray, diagram, classObject, className) {
  primitivesJsonArray.pushObject(classObject);
  let caseObjectsString = diagram.get('caseObjectsString');
  let mockCaseObjectsString = caseObjectsString ? caseObjectsString + ';' : '';
  let newCaseObjectsString = mockCaseObjectsString + `Class:(${className})`;
  diagram.set('caseObjectsString', newCaseObjectsString);
}

/**
  Get class object.
*/
function getClassObject(primitivesJsonArray, diagram, devClass, type) {
  let classId = devClass.get('id');
  let classObject = primitivesJsonArray.findBy('RepositoryObject', '{' + classId + '}');
  if (!classObject) {
    let className = devClass.get('name');
    let index = getLocationIndexNewClass(primitivesJsonArray, type);
    classObject = getJsonForClass(devClass, type, index);
    updatePrimitivesJson(primitivesJsonArray, diagram, classObject, className);
    devClass.incrementProperty('referenceCount');
  }

  return classObject;
}

/**
  Get location index for new class.
*/
function getLocationIndexNewClass(primitivesJsonArray, type) {
  let minValue;
  let value;
  switch (type) {
    case 'child':
      value = 400;
      minValue = 500;
      break;
    case 'master':
      value = 100;
      minValue = 0;
      break;
    case 'detail':
      value = 700;
      minValue = 0;
      break;
  }

  let classesSelectedType = primitivesJsonArray.filter(function(item) {
    return item.$type === 'STORMCASE.STORMNET.Repository.CADClass, STORM.NET Case Tool plugin' &&
     item.Location.X === value && item.Location.Y > minValue;
  });

  return classesSelectedType.length;
}

/**
  Get count links.
*/
function getCountLinks(primitivesJsonArray, classObject) {
  let classObjectId = classObject.$id;
  let selectedLinks = primitivesJsonArray.filter(function(item) {
    return item.$type !== 'STORMCASE.STORMNET.Repository.CADClass, STORM.NET Case Tool plugin' &&
     (item.StartPrimitive.$ref === classObjectId || item.EndPrimitive.$ref === classObjectId);
  });

  return selectedLinks.length;
}

/**
  Update primitives json array.
*/
function updatePrimitivesJsonArray(primitivesJsonArray, object, diagram, callbackGetJson, options) {
  let newObject;
  let oldObject = primitivesJsonArray.findBy('RepositoryObject', '{' + object.id + '}');
  if (oldObject) {
    let oldData = {
      uuid: oldObject.$id,
      location: oldObject.Location,
      startPoint: oldObject.StartPoint,
      endPoint: oldObject.EndPoint,
      folded: oldObject.Folded
    };

    if (isNone(options)) {
      newObject = callbackGetJson(object, null, null, oldData);
    } else {
      newObject = callbackGetJson(options.startClassObject, options.endClassObject, object, 0, oldData);
    }

    let index = primitivesJsonArray.indexOf(oldObject);
    primitivesJsonArray.replace(index, 1, newObject);
  } else {
    if (isNone(options)) {
      newObject = callbackGetJson(object);
      let className = object.get('name');
      updatePrimitivesJson(primitivesJsonArray, diagram, newObject, className);
    } else {
      let countLinks = getCountLinks(primitivesJsonArray, options.classForCountLinks);
      newObject = callbackGetJson(options.startClassObject, options.endClassObject, object, countLinks);
      primitivesJsonArray.pushObject(newObject);
    }

    object.incrementProperty('referenceCount');
  }
}

/**
  Records classes and his properties on diagram.
*/
let updateClassOnDiagram = function(store, devClass) {

  let currentProjectContext = getOwner(this).lookup('service:fd-current-project-context');
  let className = devClass.get('name');
  let diagrams = findDiagrams(store, currentProjectContext, className);

  diagrams.forEach((diagram) => {
    // Parse string to array.
    let primitivesJsonString = diagram.get('primitivesJsonString');
    let primitivesJsonArray = A(JSON.parse(primitivesJsonString));

    // Create class on diagram.
    updatePrimitivesJsonArray(primitivesJsonArray, devClass, diagram, getJsonForClass);

    // Parse array to string.
    let newPrimitivesJsonString = JSON.stringify(primitivesJsonArray);
    diagram.set('primitivesJsonString', newPrimitivesJsonString);
  });

  return all([
    devClass.save(),
    diagrams.map(a => a.save())
  ]);
};

/**
  Association on diagram.
*/
let updateAssociationOnDiagram = function(store, devAssociation) {

  let currentProjectContext = getOwner(this).lookup('service:fd-current-project-context');
  let startClass = devAssociation.get('startClass');
  let endClass = devAssociation.get('endClass');
  let startClassName = startClass.get('name');
  let endClassName = endClass.get('name');

  let diagrams = findDiagrams(store, currentProjectContext, endClassName, startClassName, devAssociation);

  diagrams.forEach((diagram) => {
    // Parse string to array.
    let primitivesJsonString = diagram.get('primitivesJsonString');
    let primitivesJsonArray = A(JSON.parse(primitivesJsonString));

    // Update diagram data.
    let endClassObject = getClassObject(primitivesJsonArray, diagram, endClass);
    let startClassObject = getClassObject(primitivesJsonArray, diagram, startClass, 'master');
    let options = {
      startClassObject: startClassObject,
      endClassObject: endClassObject,
      classForCountLinks: startClassObject
    };

    updatePrimitivesJsonArray(primitivesJsonArray, devAssociation, diagram, getJsonForAssociation, options);

    // Parse array to string.
    let newPrimitivesJsonString = JSON.stringify(primitivesJsonArray);
    diagram.set('primitivesJsonString', newPrimitivesJsonString);
  });

  return all([
    endClass.save(),
    startClass.save(),
    devAssociation.save(),
    diagrams.map(a => a.save())
  ]);
};

/**
  Aggregation on diagram.
*/
let updateAggregationOnDiagram = function(store, devAggregation) {

  let currentProjectContext = getOwner(this).lookup('service:fd-current-project-context');
  let endClass = devAggregation.get('endClass');
  let startClass = devAggregation.get('startClass');
  let endClassName = endClass.get('name');
  let startClassName = startClass.get('name');

  let diagrams = findDiagrams(store, currentProjectContext, startClassName, endClassName, devAggregation);

  diagrams.forEach((diagram) => {
    // Parse string to array.
    let primitivesJsonString = diagram.get('primitivesJsonString');
    let primitivesJsonArray = A(JSON.parse(primitivesJsonString));

    // Update diagram data.
    let endClassObject = getClassObject(primitivesJsonArray, diagram, endClass, 'detail');
    let startClassObject = getClassObject(primitivesJsonArray, diagram, startClass);
    let options = {
      startClassObject: startClassObject,
      endClassObject: endClassObject,
      classForCountLinks: endClassObject
    };

    updatePrimitivesJsonArray(primitivesJsonArray, devAggregation, diagram, getJsonForAggregation, options);

    // Parse array to string.
    let newPrimitivesJsonString = JSON.stringify(primitivesJsonArray);
    diagram.set('primitivesJsonString', newPrimitivesJsonString);
  });

  return all([
    startClass.save(),
    endClass.save(),
    devAggregation.save(),
    diagrams.map(a => a.save())
  ]);
};

/**
  Inheritance on diagram.
*/
let updateInheritanceOnDiagram = function(store, devInheritance) {

  let currentProjectContext = getOwner(this).lookup('service:fd-current-project-context');
  let parentClass = devInheritance.get('parent');
  let parentClassName = parentClass.get('name');
  let childClass = devInheritance.get('child');
  let childClassName = childClass.get('name');

  let parentDiagrams = findDiagrams(store, currentProjectContext, parentClassName, childClassName, devInheritance);
  parentDiagrams.forEach((diagram) => {
    // Parse string to array.
    let primitivesJsonString = diagram.get('primitivesJsonString');
    let primitivesJsonArray = A(JSON.parse(primitivesJsonString));

    // Update diagram data.
    let parentClassObject = getClassObject(primitivesJsonArray, diagram, parentClass);
    let childClassObject = getClassObject(primitivesJsonArray, diagram, childClass, 'child');
    let options = {
      startClassObject: parentClassObject,
      endClassObject: childClassObject,
      classForCountLinks: childClassObject
    };

    updatePrimitivesJsonArray(primitivesJsonArray, devInheritance, diagram, getJsonForInheritance, options);

    // Parse array to string.
    let newPrimitivesJsonString = JSON.stringify(primitivesJsonArray);
    diagram.set('primitivesJsonString', newPrimitivesJsonString);
  });

  if (!isNone(parentDiagrams.findBy('name', `AutogeneratedDiagramForClass_${parentClassName}`)) &&
  isNone(parentDiagrams.findBy('name', `AutogeneratedDiagramForClass_${childClassName}`))) {
    let childDiagrams = findAutogeneratedDiagram(store, childClassName, currentProjectContext);
    let diagram = childDiagrams.get('firstObject');

    // Parse string to array.
    let primitivesJsonString = diagram.get('primitivesJsonString');
    let primitivesJsonArray = A(JSON.parse(primitivesJsonString));

    // Update diagram data.
    let parentClassObject = getClassObject(primitivesJsonArray, diagram, parentClass, 'parent');
    let childClassObject = getClassObject(primitivesJsonArray, diagram, childClass);

    let options = {
      startClassObject: parentClassObject,
      endClassObject: childClassObject,
      classForCountLinks: parentClassObject
    };

    updatePrimitivesJsonArray(primitivesJsonArray, devInheritance, diagram, getJsonForInheritance, options);

    // Parse array to string.
    let newPrimitivesJsonString = JSON.stringify(primitivesJsonArray);
    diagram.set('primitivesJsonString', newPrimitivesJsonString);
    parentDiagrams.pushObject(diagram);
  }

  return all([
    parentClass.save(),
    childClass.save(),
    devInheritance.save(),
    parentDiagrams.map(a => a.save())
  ]);
};

export {
  updateClassOnDiagram,
  updateAssociationOnDiagram,
  updateAggregationOnDiagram,
  updateInheritanceOnDiagram
};
